# defmodule Kyozo.Billing.SafeMD do
  @moduledoc """
  SafeMD-specific billing integration with Stripe.

  Handles:
  - Usage-based billing at $0.03 per scan
  - Credit packages for bulk purchases
  - Subscription tiers with included scans
  - Webhook processing
  """

  require Logger
  alias Kyozo.Billing

  # $0.03 per scan
  @scan_price_cents 3

  # Stripe configuration
  @stripe_config %{
    # Products (create these in Stripe Dashboard)
    products: %{
      safemd_scan: "prod_SafeMDScan",
      credit_package: "prod_SafeMDCredits",
      subscription: "prod_SafeMDSubscription"
    },

    # Prices
    prices: %{
      # Usage-based
      # $0.03 per scan
      scan_metered: "price_SafeMDScanMetered",

      # One-time credit packages
      # $25 for 1,000 scans (2.5¢ each)
      credits_1k: "price_Credits1K",
      # $200 for 10,000 scans (2¢ each)
      credits_10k: "price_Credits10K",
      # $1,500 for 100,000 scans (1.5¢ each)
      credits_100k: "price_Credits100K",

      # Subscriptions with included scans
      # $49/mo - 2,000 scans included
      starter_monthly: "price_StarterMonthly",
      # $299/mo - 15,000 scans included
      professional_monthly: "price_ProMonthly",
      # $999/mo - 100,000 scans included
      enterprise_monthly: "price_EnterpriseMonthly"
    }
  }

  @doc """
  Record a scan for billing purposes.
  Handles credit deduction or usage recording.
  """
  def record_scan(user, metadata \\ %{}) do
    with {:ok, _} <- check_scan_permission(user) do
      cond do
        # First check prepaid credits
        has_credits?(user) ->
          deduct_credit(user, metadata)

        # Then check subscription allowance
        within_subscription_allowance?(user) ->
          record_subscription_usage(user, metadata)

        # Finally, charge pay-as-you-go
        true ->
          record_metered_usage(user, metadata)
      end
    end
  end

  @doc """
  Create a Stripe checkout session for purchasing credits or subscriptions.
  """
  def create_checkout_session(user, product_type, success_url, cancel_url) do
    with {:ok, customer_id} <- ensure_stripe_customer(user) do
      session_params =
        build_checkout_params(
          customer_id,
          product_type,
          success_url,
          cancel_url,
          user
        )

      case Stripe.Session.create(session_params) do
        {:ok, session} ->
          # Track checkout initiation
          track_checkout_started(user, product_type, session.id)
          {:ok, session}

        error ->
          Logger.error("Failed to create checkout session: #{inspect(error)}")
          error
      end
    end
  end

  @doc """
  Get current usage and billing status for a user.
  """
  def get_billing_status(user) do
    %{
      credits: get_credit_balance(user),
      subscription: get_subscription_info(user),
      current_usage: get_current_month_usage(user),
      overage_charges: calculate_overage_charges(user)
    }
  end

  @doc """
  Handle Stripe webhook events.
  """
  def handle_webhook(event) do
    case event.type do
      "checkout.session.completed" ->
        handle_checkout_completed(event.data.object)

      "invoice.payment_succeeded" ->
        handle_invoice_paid(event.data.object)

      "customer.subscription.updated" ->
        handle_subscription_updated(event.data.object)

      "customer.subscription.deleted" ->
        handle_subscription_cancelled(event.data.object)

      _ ->
        Logger.info("Unhandled webhook event: #{event.type}")
        :ok
    end
  end

  # Private functions

  defp check_scan_permission(user) do
    cond do
      has_credits?(user) -> {:ok, :credits}
      has_active_subscription?(user) -> {:ok, :subscription}
      has_payment_method?(user) -> {:ok, :pay_as_you_go}
      true -> {:error, :no_payment_method}
    end
  end

  defp has_credits?(user) do
    Billing.get_credit_balance(user, "safemd_scan") > 0
  end

  defp deduct_credit(user, metadata) do
    Billing.deduct_credits(user, 1, "safemd_scan", metadata)
    track_scan(user, :credit, metadata)
  end

  defp within_subscription_allowance?(user) do
    case get_subscription_info(user) do
      %{status: "active", remaining_scans: remaining} when remaining > 0 ->
        true

      _ ->
        false
    end
  end

  defp record_subscription_usage(user, metadata) do
    # Increment subscription usage counter
    Billing.increment_subscription_usage(user, "safemd_scan", 1)
    track_scan(user, :subscription, metadata)
  end

  defp record_metered_usage(user, metadata) do
    with {:ok, customer_id} <- ensure_stripe_customer(user),
         {:ok, subscription} <- get_or_create_metered_subscription(customer_id) do
      # Find metered price item
      metered_item = find_metered_item(subscription)

      # Record usage
      Stripe.SubscriptionItem.create_usage_record(metered_item.id, %{
        quantity: 1,
        timestamp: DateTime.to_unix(DateTime.utc_now()),
        action: "increment"
      })

      track_scan(user, :metered, metadata)
    end
  end

  defp ensure_stripe_customer(user) do
    case Billing.get_stripe_customer_id(user) do
      nil ->
        create_stripe_customer(user)

      customer_id ->
        {:ok, customer_id}
    end
  end

  defp create_stripe_customer(user) do
    params = %{
      email: user.email,
      name: user.name || user.email,
      metadata: %{
        user_id: user.id,
        environment: Application.get_env(:kyozo, :environment)
      }
    }

    case Stripe.Customer.create(params) do
      {:ok, customer} ->
        Billing.set_stripe_customer_id(user, customer.id)
        {:ok, customer.id}

      error ->
        error
    end
  end

  defp get_or_create_metered_subscription(customer_id) do
    # Check for existing metered subscription
    case Stripe.Subscription.list(%{
           customer: customer_id,
           price: @stripe_config.prices.scan_metered
         }) do
      {:ok, %{data: [subscription | _]}} ->
        {:ok, subscription}

      {:ok, %{data: []}} ->
        # Create metered subscription
        Stripe.Subscription.create(%{
          customer: customer_id,
          items: [%{price: @stripe_config.prices.scan_metered}],
          metadata: %{type: "metered_scans"}
        })

      error ->
        error
    end
  end

  defp build_checkout_params(customer_id, product_type, success_url, cancel_url, user) do
    base_params = %{
      customer: customer_id,
      success_url: success_url <> "?session_id={CHECKOUT_SESSION_ID}",
      cancel_url: cancel_url,
      metadata: %{
        user_id: user.id,
        product_type: to_string(product_type)
      }
    }

    case product_type do
      :credits_1k ->
        Map.merge(base_params, %{
          line_items: [%{price: @stripe_config.prices.credits_1k, quantity: 1}],
          mode: "payment"
        })

      :credits_10k ->
        Map.merge(base_params, %{
          line_items: [%{price: @stripe_config.prices.credits_10k, quantity: 1}],
          mode: "payment"
        })

      :credits_100k ->
        Map.merge(base_params, %{
          line_items: [%{price: @stripe_config.prices.credits_100k, quantity: 1}],
          mode: "payment"
        })

      :starter_monthly ->
        Map.merge(base_params, %{
          line_items: [%{price: @stripe_config.prices.starter_monthly, quantity: 1}],
          mode: "subscription"
        })

      :professional_monthly ->
        Map.merge(base_params, %{
          line_items: [%{price: @stripe_config.prices.professional_monthly, quantity: 1}],
          mode: "subscription"
        })

      :enterprise_monthly ->
        Map.merge(base_params, %{
          line_items: [%{price: @stripe_config.prices.enterprise_monthly, quantity: 1}],
          mode: "subscription"
        })
    end
  end

  defp handle_checkout_completed(session) do
    with {:ok, full_session} <- Stripe.Session.retrieve(session.id, %{expand: ["line_items"]}),
         {:ok, user} <- get_user_by_stripe_customer(full_session.customer) do
      case full_session.metadata.product_type do
        "credits_" <> package ->
          add_credit_package(user, package, full_session)

        subscription_type
        when subscription_type in ~w(starter_monthly professional_monthly enterprise_monthly) ->
          activate_subscription(user, subscription_type, full_session)

        _ ->
          Logger.warning("Unknown product type: #{full_session.metadata.product_type}")
      end
    end
  end

  defp add_credit_package(user, package, session) do
    credits =
      case package do
        "1k" -> 1_000
        "10k" -> 10_000
        "100k" -> 100_000
      end

    Billing.add_credits(user, credits, "safemd_scan", %{
      stripe_session_id: session.id,
      package: package
    })

    # Send confirmation email
    Kyozo.Emails.send_credit_purchase_confirmation(user, credits)
  end

  defp get_subscription_info(user) do
    case Billing.get_active_subscription(user, "safemd") do
      nil ->
        nil

      subscription ->
        included_scans = get_included_scans(subscription.plan)
        used_scans = get_current_month_usage(user)

        %{
          status: subscription.status,
          plan: subscription.plan,
          included_scans: included_scans,
          used_scans: used_scans,
          remaining_scans: max(0, included_scans - used_scans),
          current_period_end: subscription.current_period_end
        }
    end
  end

  defp get_included_scans("starter_monthly"), do: 2_000
  defp get_included_scans("professional_monthly"), do: 15_000
  defp get_included_scans("enterprise_monthly"), do: 100_000
  defp get_included_scans(_), do: 0

  defp track_scan(user, type, metadata) do
    :telemetry.execute(
      [:kyozo, :safemd, :scan],
      %{count: 1},
      Map.merge(metadata, %{
        user_id: user.id,
        billing_type: type
      })
    )
  end

  defp track_checkout_started(user, product_type, session_id) do
    :telemetry.execute(
      [:kyozo, :safemd, :checkout, :started],
      %{count: 1},
      %{
        user_id: user.id,
        product_type: product_type,
        session_id: session_id
      }
    )
  end
end
