import Foundation

// MARK: - VFS Usage Examples

public extension KyozoClient {
    /// Example: Browse a workspace with virtual files
    func browseWorkspaceWithVirtualFiles(teamId: String, workspaceId: String) async throws {
        // List root directory including virtual files
        let listing = try await vfs.list(teamId: teamId, workspaceId: workspaceId, path: "/")
        
        print("Total files: \(listing.files.count)")
        print("Virtual files: \(listing.virtualCount)")
        
        // Separate real and virtual files
        let virtualFiles = listing.files.filter { $0.virtual }
        let realFiles = listing.files.filter { !$0.virtual }
        
        print("\nReal files:")
        for file in realFiles {
            print("  📄 \(file.name) (\(file.contentType))")
        }
        
        print("\nVirtual files:")
        for file in virtualFiles {
            print("  ✨ \(file.name) - generated by \(file.generator ?? "unknown")")
        }
        
        // Read a virtual guide file
        if let guideFile = virtualFiles.first(where: { $0.name == "guide.md" }) {
            let content = try await vfs.readContent(
                teamId: teamId,
                workspaceId: workspaceId,
                path: guideFile.path
            )
            print("\n📖 Guide content preview:")
            print(String(content.content.prefix(200)) + "...")
        }
    }
    
    /// Example: Get all virtual documentation for a project
    func getVirtualDocumentation(teamId: String, workspaceId: String) async throws -> [VFSContent] {
        let listing = try await vfs.list(teamId: teamId, workspaceId: workspaceId)
        
        // Common virtual documentation files
        let docFiles = ["guide.md", "deploy.md", "overview.md", "getting-started.md"]
        
        var documentation: [VFSContent] = []
        
        for file in listing.files where file.virtual && docFiles.contains(file.name) {
            do {
                let content = try await vfs.readContent(
                    teamId: teamId,
                    workspaceId: workspaceId,
                    path: file.path
                )
                documentation.append(content)
            } catch {
                print("Failed to read \(file.name): \(error)")
            }
        }
        
        return documentation
    }
}

// MARK: - VFS SwiftUI Integration

#if canImport(SwiftUI)
import SwiftUI

/// Observable model for VFS file browsing
@MainActor
public class VFSBrowser: ObservableObject {
    @Published public var listing: VFSListing?
    @Published public var isLoading = false
    @Published public var error: Error?
    @Published public var selectedContent: VFSContent?
    
    private let client: KyozoClient
    private let teamId: String
    private let workspaceId: String
    
    public init(client: KyozoClient, teamId: String, workspaceId: String) {
        self.client = client
        self.teamId = teamId
        self.workspaceId = workspaceId
    }
    
    public func loadDirectory(path: String = "/") async {
        isLoading = true
        error = nil
        
        do {
            listing = try await client.vfs.list(
                teamId: teamId,
                workspaceId: workspaceId,
                path: path
            )
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
    
    public func selectFile(_ file: VFSFile) async {
        guard file.type == .file else { return }
        
        isLoading = true
        error = nil
        
        do {
            selectedContent = try await client.vfs.readContent(
                teamId: teamId,
                workspaceId: workspaceId,
                path: file.path
            )
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
}

/// SwiftUI View for displaying VFS files
public struct VFSFileListView: View {
    @ObservedObject var browser: VFSBrowser
    
    public init(browser: VFSBrowser) {
        self.browser = browser
    }
    
    public var body: some View {
        List {
            if let listing = browser.listing {
                Section {
                    ForEach(listing.files.filter { !$0.virtual }, id: \.path) { file in
                        FileRow(file: file, browser: browser)
                    }
                } header: {
                    Label("Files", systemImage: "folder")
                }
                
                if listing.virtualCount > 0 {
                    Section {
                        ForEach(listing.files.filter { $0.virtual }, id: \.path) { file in
                            FileRow(file: file, browser: browser)
                        }
                    } header: {
                        Label("Virtual Files", systemImage: "sparkles")
                    }
                }
            }
        }
        .navigationTitle(browser.listing?.path ?? "/")
        .task {
            await browser.loadDirectory()
        }
        .overlay {
            if browser.isLoading {
                ProgressView()
            }
        }
        .alert("Error", isPresented: .constant(browser.error != nil)) {
            Button("OK") {
                browser.error = nil
            }
        } message: {
            Text(browser.error?.localizedDescription ?? "Unknown error")
        }
    }
}

struct FileRow: View {
    let file: VFSFile
    let browser: VFSBrowser
    
    var body: some View {
        Button {
            Task {
                await browser.selectFile(file)
            }
        } label: {
            HStack {
                Text(file.icon ?? (file.type == .directory ? "📁" : "📄"))
                
                VStack(alignment: .leading) {
                    Text(file.name)
                        .foregroundColor(.primary)
                    
                    if file.virtual, let generator = file.generator {
                        Text("Generated by \(generator)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                
                Spacer()
                
                if file.type == .directory {
                    Image(systemName: "chevron.right")
                        .foregroundColor(.secondary)
                }
            }
        }
        .buttonStyle(.plain)
    }
}

/// View for displaying VFS content
public struct VFSContentView: View {
    let content: VFSContent
    
    public init(content: VFSContent) {
        self.content = content
    }
    
    public var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                // Header
                VStack(alignment: .leading, spacing: 8) {
                    Label(content.path, systemImage: content.virtual ? "sparkles" : "doc.text")
                        .font(.headline)
                    
                    Text(content.contentType)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 2)
                        .background(Color.secondary.opacity(0.2))
                        .clipShape(Capsule())
                }
                .padding(.horizontal)
                
                Divider()
                
                // Content
                if content.contentType.contains("markdown") {
                    // In a real app, you'd use a markdown renderer here
                    Text(content.content)
                        .font(.system(.body, design: .monospaced))
                        .padding(.horizontal)
                } else {
                    Text(content.content)
                        .font(.system(.body, design: .monospaced))
                        .padding(.horizontal)
                }
            }
            .padding(.vertical)
        }
        .navigationTitle("File Content")
        .navigationBarTitleDisplayMode(.inline)
    }
}
#endif

// MARK: - VFS Combine Support

#if canImport(Combine)
import Combine

public extension KyozoClient {
    /// Publisher for VFS directory listing
    func vfsListingPublisher(teamId: String, workspaceId: String, path: String = "/") -> AnyPublisher<VFSListing, Error> {
        Future { promise in
            Task {
                do {
                    let listing = try await self.vfs.list(
                        teamId: teamId,
                        workspaceId: workspaceId,
                        path: path
                    )
                    promise(.success(listing))
                } catch {
                    promise(.failure(error))
                }
            }
        }
        .eraseToAnyPublisher()
    }
    
    /// Publisher for VFS content
    func vfsContentPublisher(teamId: String, workspaceId: String, path: String) -> AnyPublisher<VFSContent, Error> {
        Future { promise in
            Task {
                do {
                    let content = try await self.vfs.readContent(
                        teamId: teamId,
                        workspaceId: workspaceId,
                        path: path
                    )
                    promise(.success(content))
                } catch {
                    promise(.failure(error))
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
#endif

// MARK: - VFS Caching

/// Simple in-memory cache for VFS content
public class VFSCache {
    private var contentCache: [String: (content: VFSContent, timestamp: Date)] = [:]
    private let cacheTimeout: TimeInterval
    
    public init(cacheTimeout: TimeInterval = 300) { // 5 minutes default
        self.cacheTimeout = cacheTimeout
    }
    
    private func cacheKey(teamId: String, workspaceId: String, path: String) -> String {
        "\(teamId):\(workspaceId):\(path)"
    }
    
    public func get(teamId: String, workspaceId: String, path: String) -> VFSContent? {
        let key = cacheKey(teamId: teamId, workspaceId: workspaceId, path: path)
        
        guard let cached = contentCache[key] else { return nil }
        
        // Check if cache is still valid
        if Date().timeIntervalSince(cached.timestamp) > cacheTimeout {
            contentCache.removeValue(forKey: key)
            return nil
        }
        
        return cached.content
    }
    
    public func set(teamId: String, workspaceId: String, path: String, content: VFSContent) {
        let key = cacheKey(teamId: teamId, workspaceId: workspaceId, path: path)
        contentCache[key] = (content, Date())
    }
    
    public func clear() {
        contentCache.removeAll()
    }
}

// MARK: - VFS + Caching Extension

public extension VFSService {
    /// Get VFS content with caching
    func readContentCached(
        teamId: String,
        workspaceId: String,
        path: String,
        cache: VFSCache
    ) async throws -> VFSContent {
        // Check cache first
        if let cached = cache.get(teamId: teamId, workspaceId: workspaceId, path: path) {
            return cached
        }
        
        // Fetch from server
        let content = try await readContent(
            teamId: teamId,
            workspaceId: workspaceId,
            path: path
        )
        
        // Cache for next time
        cache.set(teamId: teamId, workspaceId: workspaceId, path: path, content: content)
        
        return content
    }
}